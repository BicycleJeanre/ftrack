/**
 * Scenario Generator - Creates minimal test scenarios for each scenario type
 * These are lookup-driven, generated to exercise all key combinations
 */

const fs = require('fs');
const path = require('path');

// Load lookup data
const lookupPath = path.join(__dirname, '../../assets/lookup-data.json');
const lookupData = JSON.parse(fs.readFileSync(lookupPath, 'utf8'));

/**
 * Create a minimal scenario for a given scenario type
 * @param {number} scenarioTypeId - ID from lookup-data.json scenarioTypes
 * @param {number} baseScenarioId - Base ID for this scenario
 * @returns {object} Scenario object ready for QC dataset
 */
function createScenarioForType(scenarioTypeId, baseScenarioId) {
  const scenarioType = lookupData.scenarioTypes.find(s => s.id === scenarioTypeId);
  if (!scenarioType) throw new Error(`Scenario type ${scenarioTypeId} not found`);

  const baseId = baseScenarioId * 100;
  
  // Common structure for all scenarios
  const scenario = {
    id: baseScenarioId,
    name: `QC ${scenarioType.name} Scenario`,
    type: scenarioType,
    description: `Minimal QC scenario for ${scenarioType.name} type validation`,
    startDate: '2026-02-01',
    endDate: '2026-12-01',
    projectionPeriod: {
      id: 3,  // Monthly
      name: 'Month'
    },
    accounts: [],
    transactions: [],
    projections: [],
    budgets: []
  };

  // Generate accounts based on scenario type
  scenario.accounts = generateAccountsForType(scenarioTypeId, baseId);
  
  // Generate transactions based on scenario type
  scenario.transactions = generateTransactionsForType(scenarioTypeId, baseId, scenario.accounts);
  
  // Create placeholder projections (will be generated by projection engine in actual use)
  scenario.projections = generateProjectionsForType(scenario);

  // Create budgets if needed for Budget scenario type
  if (scenarioTypeId === 1) {
    scenario.budgets = generateBudgetsForBudgetScenario(baseId, scenario.accounts);
  }

  return scenario;
}

/**
 * Generate representative accounts for scenario type
 */
function generateAccountsForType(scenarioTypeId, baseId) {
  const accounts = [];

  // Add a primary asset account for all types
  accounts.push({
    id: baseId + 1,
    name: `A${baseId + 1}`,
    type: { id: 1, name: 'Asset' },
    currency: null,
    startingBalance: 50000,
    openDate: '2026-02-01',
    periodicChange: null,
    accountType: 'Unknown',
    periodicChangeSummary: '',
    description: `Primary asset for ${['Budget', 'General', 'Funds', 'Debt Repayment', 'Goal-Based', 'Advanced Goal Solver'][scenarioTypeId - 1]} scenario`
  });

  // Type-specific accounts
  switch (scenarioTypeId) {
    case 1: // Budget
      // Add income and expense accounts
      accounts.push({
        id: baseId + 2,
        name: `Income${baseId}`,
        type: { id: 4, name: 'Income' },
        currency: null,
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: { value: 5000, changeMode: 2, changeType: 1 },
        accountType: 'Income',
        description: 'Monthly income'
      });
      accounts.push({
        id: baseId + 3,
        name: `Expense${baseId}`,
        type: { id: 5, name: 'Expense' },
        currency: null,
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: { value: 1000, changeMode: 2, changeType: 1 },
        accountType: 'Expense',
        description: 'Monthly expenses'
      });
      break;

    case 2: // General - already covered by main asset
      break;

    case 3: // Funds
      // Add investment fund accounts
      accounts.push({
        id: baseId + 2,
        name: `Fund${baseId}`,
        type: { id: 1, name: 'Asset' },
        currency: null,
        startingBalance: 100000,
        openDate: '2026-02-01',
        periodicChange: { value: 7, changeMode: 1, changeType: 2 },
        accountType: 'Unknown',
        description: 'Investment fund with 7% monthly compound interest'
      });
      break;

    case 4: // Debt Repayment
      // Add liability and payment accounts
      accounts.push({
        id: baseId + 2,
        name: `Debt${baseId}`,
        type: { id: 2, name: 'Liability' },
        currency: null,
        startingBalance: 25000,
        openDate: '2026-02-01',
        periodicChange: { value: 2, changeMode: 1, changeType: 1 },
        accountType: 'Unknown',
        description: 'Debt with 2% monthly interest'
      });
      break;

    case 5: // Goal-Based
      // Add goal tracking account
      accounts.push({
        id: baseId + 2,
        name: `GoalAccount${baseId}`,
        type: { id: 1, name: 'Asset' },
        currency: null,
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: null,
        accountType: 'Unknown',
        description: 'Goal-based savings target'
      });
      break;

    case 6: // Advanced Goal Solver
      // Add multiple goal accounts
      for (let i = 1; i <= 3; i++) {
        accounts.push({
          id: baseId + 1 + i,
          name: `Goal${i}-${baseId}`,
          type: { id: 1, name: 'Asset' },
          currency: null,
          startingBalance: 0,
          openDate: '2026-02-01',
          periodicChange: null,
          accountType: 'Unknown',
          description: `Goal ${i} for advanced solver`
        });
      }
      break;
  }

  return accounts;
}

/**
 * Generate representative transactions for scenario type
 */
function generateTransactionsForType(scenarioTypeId, baseId, accounts) {
  const transactions = [];

  switch (scenarioTypeId) {
    case 1: // Budget - monthly budgeted transactions
      if (accounts.length >= 3) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Budget Transfer ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 1,
          amount: 5000,
          description: 'Monthly income transfer',
          recurrence: { id: 2, name: 'Monthly', frequency: 1, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['income']
        });
      }
      break;

    case 3: // Funds - periodic withdrawals
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Fund Withdrawal ${baseId}`,
          primaryAccount: accounts[1],
          secondaryAccount: accounts[0],
          transactionType: 2,
          amount: 5000,
          description: 'Quarterly fund withdrawal',
          recurrence: { id: 4, name: 'Quarterly', frequency: 3, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['withdrawal']
        });
      }
      break;

    case 4: // Debt Repayment - monthly payments
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Debt Payment ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 2,
          amount: 1000,
          description: 'Monthly debt repayment',
          recurrence: { id: 2, name: 'Monthly', frequency: 1, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['payment', 'debt']
        });
      }
      break;

    case 5: // Goal-Based - automated savings to goal
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Goal Contribution ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 1,
          amount: 2000,
          description: 'Monthly goal contribution',
          recurrence: { id: 2, name: 'Monthly', frequency: 1, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['goal', 'savings']
        });
      }
      break;

    case 6: // Advanced Goal Solver - multi-goal funding
      if (accounts.length >= 3) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Goal1 Fund ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 1,
          amount: 1000,
          description: 'Goal 1 funding',
          recurrence: { id: 2, name: 'Monthly', frequency: 1, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['goal1', 'solver']
        });
      }
      break;
  }

  return transactions;
}

/**
 * Generate placeholder projections
 */
function generateProjectionsForType(scenario) {
  const projections = [];
  const startDate = new Date('2026-02-01');
  const accountIds = scenario.accounts.map(a => a.id);

  // Create monthly projections for each account
  for (let month = 0; month <= 10; month++) {
    const date = new Date(startDate);
    date.setMonth(date.getMonth() + month);
    
    accountIds.forEach((accountId, idx) => {
      projections.push({
        id: projections.length + 1,
        scenarioId: scenario.id,
        accountId: accountId,
        account: scenario.accounts[idx].name,
        date: date.toISOString().split('T')[0],
        balance: scenario.accounts[idx].startingBalance,
        income: 0,
        expenses: 0,
        netChange: 0,
        period: month + 1
      });
    });
  }

  return projections;
}

/**
 * Generate budgets for Budget scenario type
 */
function generateBudgetsForBudgetScenario(baseId, accounts) {
  const budgets = [];
  
  const incomeAccount = accounts.find(a => a.type.id === 4);
  const expenseAccount = accounts.find(a => a.type.id === 5);

  if (incomeAccount) {
    budgets.push({
      id: baseId + 1,
      name: `Income Budget ${baseId}`,
      accountId: incomeAccount.id,
      amount: 5000,
      period: { id: 3, name: 'Month' },
      startDate: '2026-02-01',
      endDate: '2026-12-01'
    });
  }

  if (expenseAccount) {
    budgets.push({
      id: baseId + 2,
      name: `Expense Budget ${baseId}`,
      accountId: expenseAccount.id,
      amount: 1000,
      period: { id: 3, name: 'Month' },
      startDate: '2026-02-01',
      endDate: '2026-12-01'
    });
  }

  return budgets;
}

/**
 * Generate expected outputs for a scenario
 */
function createExpectedOutputsForScenario(scenario) {
  return {
    id: scenario.id,
    name: scenario.name,
    expectedOutputs: {
      accountCount: scenario.accounts.length,
      transactionCount: scenario.transactions.length,
      projectionCount: scenario.projections.length,
      budgetCount: scenario.budgets.length,
      firstProjection: scenario.projections.length > 0 ? {
        date: scenario.projections[0].date,
        accountId: scenario.projections[0].accountId,
        balance: scenario.projections[0].balance,
        income: scenario.projections[0].income,
        expenses: scenario.projections[0].expenses,
        netChange: scenario.projections[0].netChange
      } : null,
      lastProjection: scenario.projections.length > 0 ? {
        date: scenario.projections[scenario.projections.length - 1].date,
        accountId: scenario.projections[scenario.projections.length - 1].accountId,
        balance: scenario.projections[scenario.projections.length - 1].balance
      } : null,
      transactionCount: scenario.transactions.length,
      budgetCount: scenario.budgets.length
    }
  };
}

module.exports = {
  createScenarioForType,
  createExpectedOutputsForScenario,
  generateAccountsForType,
  generateTransactionsForType,
  generateProjectionsForType
};
