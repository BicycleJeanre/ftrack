/**
 * Scenario Generator - Creates minimal test scenarios for each scenario type
 * These are lookup-driven, generated to exercise all key combinations
 */

const fs = require('fs');
const path = require('path');

// Load lookup data
const lookupPath = path.join(__dirname, '../../assets/lookup-data.json');
const lookupData = JSON.parse(fs.readFileSync(lookupPath, 'utf8'));

/**
 * Create a minimal scenario for a given scenario type
 * @param {number} scenarioTypeId - ID from lookup-data.json scenarioTypes
 * @param {number} baseScenarioId - Base ID for this scenario
 * @returns {object} Scenario object ready for QC dataset
 */
function createScenarioForType(scenarioTypeId, baseScenarioId) {
  const scenarioType = lookupData.scenarioTypes.find(s => s.id === scenarioTypeId);
  if (!scenarioType) throw new Error(`Scenario type ${scenarioTypeId} not found`);

  const baseId = baseScenarioId * 100;
  
  // Common structure for all scenarios (schema-compliant)
  const scenario = {
    id: baseScenarioId,
    name: `QC ${scenarioType.name} Scenario`,
    type: scenarioType.id,
    description: `Minimal QC scenario for ${scenarioType.name} type validation`,
    startDate: '2026-02-01',
    endDate: '2026-12-01',
    projectionPeriod: 3,  // Monthly
    accounts: [],
    transactions: [],
    projections: [],
    budgets: []
  };

  // Generate accounts based on scenario type
  scenario.accounts = generateAccountsForType(scenarioTypeId, baseId);
  
  // Generate transactions based on scenario type
  scenario.transactions = generateTransactionsForType(scenarioTypeId, baseId, scenario.accounts);
  
  // Create placeholder projections (will be generated by projection engine in actual use)
  scenario.projections = generateProjectionsForType(scenario);

  // Create budgets if needed for Budget scenario type
  if (scenarioTypeId === 1) {
    scenario.budgets = generateBudgetsForBudgetScenario(baseId, scenario.accounts);
  }

  return scenario;
}

/**
 * Generate representative accounts for scenario type
 */
function generateAccountsForType(scenarioTypeId, baseId) {
  const accounts = [];

  // Add a primary asset account for all types (schema-compliant)
  accounts.push({
    id: baseId + 1,
    name: `A${baseId + 1}`,
    type: 1,  // Asset
    currency: 1,  // ZAR
    startingBalance: 50000,
    openDate: '2026-02-01',
    periodicChange: null,
    goalAmount: null,
    goalDate: null
  });

  // Type-specific accounts
  switch (scenarioTypeId) {
    case 1: // Budget
      // Add income a (schema-compliant)
      accounts.push({
        id: baseId + 2,
        name: `Income${baseId}`,
        type: 4,  // Income
        currency: 1,  // ZAR
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: { value: 5000, changeMode: 2, period: 3 },  // Fixed monthly
        goalAmount: null,
        goalDate: null
      });
      accounts.push({
        id: baseId + 3,
        name: `Expense${baseId}`,
        type: 5,  // Expense
        currency: 1,  // ZAR
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: { value: 1000, changeMode: 2, period: 3 },
        goalAmount: null,
        goalDate: null
      break;

    case 2: // General - already covered by main asset
      break;

    case 3: // Funds
      // Add investm (schema-compliant)
      accounts.push({
        id: baseId + 2,
        name: `Fund${baseId}`,
        type: 1,  // Asset
        currency: 1,  // ZAR
        startingBalance: 100000,
        openDate: '2026-02-01',
        periodicChange: { value: 7, changeMode: 1, changeType: 2 },
        goalAmount: null,
        goalDate: null
      break;

    case 4: // Debt Repayment
      // Add liability and payment accounts
      accounts.push({ (schema-compliant)
      accounts.push({
        id: baseId + 2,
        name: `Debt${baseId}`,
        type: 2,  // Liability
        currency: 1,  // ZAR
        startingBalance: 25000,
        openDate: '2026-02-01',
        periodicChange: { value: 2, changeMode: 1, changeType: 1 },
        goalAmount: null,
        goalDate: null

    case 5: // Goal-Based
      // Add goal tracking account
      accounts.push({
        id: baseId + 2, (schema-compliant)
      accounts.push({
        id: baseId + 2,
        name: `GoalAccount${baseId}`,
        type: 1,  // Asset
        currency: 1,  // ZAR
        startingBalance: 0,
        openDate: '2026-02-01',
        periodicChange: null,
        goalAmount: null,
        goalDate: null
    case 6: // Advanced Goal Solver
      // Add multiple goal accounts
      for (let i = 1; i <= 3; i++) {
        accounts.push({ (schema-compliant)
      for (let i = 1; i <= 3; i++) {
        accounts.push({
          id: baseId + 1 + i,
          name: `Goal${i}-${baseId}`,
          type: 1,  // Asset
          currency: 1,  // ZAR
          startingBalance: 0,
          openDate: '2026-02-01',
          periodicChange: null,
          goalAmount: null,
          goalDate: null
  }

  return accounts;
}

/**
 * Generate representative transactions for scenario type
 */
function generateTransactionsForType(scenarioTypeId, baseId, accounts) {
  const transactions = [];

  switch (scenarioTypeId) {
    case 1: // Budget - monthly budgeted transactions
      if (accounts.length >= 3) {
        transactions.push({
          id: baseId + 1,
          sourceId: ba(schema-compliant)
      if (accounts.length >= 3) {
        transactions.push({
          id: baseId + 1,
          primaryAccountId: accounts[0].id,
          secondaryAccountId: accounts[1].id,
          transactionTypeId: 1,  // Income
          amount: 5000,
          description: 'Monthly income transfer',
          recurrence: {
            recurrenceType: 4,  // Monthly - Day of Month
            startDate: '2026-02-01',
            endDate: null,
            interval: 1,
            dayOfWeek: null,
            dayOfMonth: 1,
            weekOfMonth: null,
            dayOfWeek(schema-compliant)
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          primaryAccountId: accounts[1].id,
          secondAccountId: accounts[0].id,
          transactionTypeId: 2,  // Expense
          amount: 5000,
          description: 'Quarterly fund withdrawal',
          recurrence: {
            recurrenceType: 6,  // Quarterly
            startDate: '2026-02-01',
            endDate: null,
            interval: null,
            dayOfWeek: null,
            dayOfMonth: null,
            weekOfMonth: null,
            dayOfWeekInMonth: null,
            dayOfQuarter: 1,(schema-compliant)
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          primaryAccountId: accounts[0].id,
          secondaryAccountId: accounts[1].id,
          transactionTypeId: 2,  // Expense
          amount: 1000,
          description: 'Monthly debt repayment',
          recurrence: {
            recurrenceType: 4,  // Monthly - Day of Month
            startDate: '2026-02-01',
            endDate: null,
            interval: 1,
            dayOfWeek: null,
            dayOfMonth: 1,
            weekOfMonth: null,
            dayOfWeekInMon(schema-compliant)
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          primaryAccountId: accounts[0].id,
          secondaryAccountId: accounts[1].id,
          transactionTypeId: 1,  // Income
          amount: 2000,
          description: 'Monthly goal contribution',
          recurrence: {
            recurrenceType: 4,  // Monthly - Day of Month
            startDate: '2026-02-01',
            endDate: null,
            interval: 1,
            dayOfWeek: null,
            dayOfMonth: 1,
            weekOfMonth: null,
            dayOfWeekInMonth: null,
            dayOfQuarter: null,(schema-compliant)
      if (accounts.length >= 3) {
        transactions.push({
          id: baseId + 1,
          primaryAccountId: accounts[0].id,
          secondaryAccountId: accounts[1].id,
          transactionTypeId: 1,  // Income
          amount: 1000,
          description: 'Goal 1 funding',
          recurrence: {
            recurrenceType: 4,  // Monthly - Day of Month
            startDate: '2026-02-01',
            endDate: null,
            interval: 1,
            dayOfWeek: null,
            dayOfMonth: 1,
            weekOfMonth: null,
            dayOfWeekInMonth: null,
            dayOfQuarter: null,
            month: null,
            dayOfYear: null,
            customDates: null,
            id: null
          },
          periodicChange: null,
          status: { name: 'planned', actualAmount: null, actualDate: null }

    case 4: // Debt Repayment - monthly payments
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Debt Payment ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 2,
          amount: 1000,
          description: 'Monthly debt repayment',
          recurrence: { id: 2, name: 'Monthly', frequency: 1, startDate: '2026-02-01' },
          periodicChange: null,
          tags: ['payment', 'debt']
        });
      }
      break;

    case 5: // Goal-Based - automated savings to goal
      if (accounts.length >= 2) {
        transactions.push({
          id: baseId + 1,
          sourceId: baseId + 1,
          baseName: `Goal Contribution ${baseId}`,
          primaryAccount: accounts[0],
          secondaryAccount: accounts[1],
          transactionType: 1,
          amount: 2000, (schema-compliant)
 */
function generateBudgetsForBudgetScenario(baseId, accounts) {
  const budgets = [];
  
  const incomeAccount = accounts.find(a => a.type === 4);
  const expenseAccount = accounts.find(a => a.type === 5);

  if (incomeAccount) {
    budgets.push({
      id: baseId + 1,
      name: `Income Budget ${baseId}`,
      accountId: incomeAccount.id,
      amount: 5000,
      period: 3,  // Monthly
      startDate: '2026-02-01',
      endDate: '2026-12-01'
    });
  }

  if (expenseAccount) {
    budgets.push({
      id: baseId + 2,
      name: `Expense Budget ${baseId}`,
      accountId: expenseAccount.id,
      amount: 1000,
      period: 3,  // Monthly

  return transactions;
}

/**
 * Generate placeholder projections
 */
function generateProjectionsForType(scenario) {
  const projections = [];
  const startDate = new Date('2026-02-01');
  const accountIds = scenario.accounts.map(a => a.id);

  // Create monthly projections for each account
  for (let month = 0; month <= 10; month++) {
    const date = new Date(startDate);
    date.setMonth(date.getMonth() + month);
    
    accountIds.forEach((accountId, idx) => {
      projections.push({
        id: projections.length + 1,
        scenarioId: scenario.id,
        accountId: accountId,
        account: scenario.accounts[idx].name,
        date: date.toISOString().split('T')[0],
        balance: scenario.accounts[idx].startingBalance,
        income: 0,
        expenses: 0,
        netChange: 0,
        period: month + 1
      });
    });
  }

  return projections;
}

/**
 * Generate budgets for Budget scenario type
 */
function generateBudgetsForBudgetScenario(baseId, accounts) {
  const budgets = [];
  
  const incomeAccount = accounts.find(a => a.type.id === 4);
  const expenseAccount = accounts.find(a => a.type.id === 5);

  if (incomeAccount) {
    budgets.push({
      id: baseId + 1,
      name: `Income Budget ${baseId}`,
      accountId: incomeAccount.id,
      amount: 5000,
      period: { id: 3, name: 'Month' },
      startDate: '2026-02-01',
      endDate: '2026-12-01'
    });
  }

  if (expenseAccount) {
    budgets.push({
      id: baseId + 2,
      name: `Expense Budget ${baseId}`,
      accountId: expenseAccount.id,
      amount: 1000,
      period: { id: 3, name: 'Month' },
      startDate: '2026-02-01',
      endDate: '2026-12-01'
    });
  }

  return budgets;
}

/**
 * Generate expected outputs for a scenario
 */
function createExpectedOutputsForScenario(scenario) {
  return {
    id: scenario.id,
    name: scenario.name,
    expectedOutputs: {
      accountCount: scenario.accounts.length,
      transactionCount: scenario.transactions.length,
      projectionCount: scenario.projections.length,
      budgetCount: scenario.budgets.length,
      firstProjection: scenario.projections.length > 0 ? {
        date: scenario.projections[0].date,
        accountId: scenario.projections[0].accountId,
        balance: scenario.projections[0].balance,
        income: scenario.projections[0].income,
        expenses: scenario.projections[0].expenses,
        netChange: scenario.projections[0].netChange
      } : null,
      lastProjection: scenario.projections.length > 0 ? {
        date: scenario.projections[scenario.projections.length - 1].date,
        accountId: scenario.projections[scenario.projections.length - 1].accountId,
        balance: scenario.projections[scenario.projections.length - 1].balance
      } : null,
      transactionCount: scenario.transactions.length,
      budgetCount: scenario.budgets.length
    }
  };
}

module.exports = {
  createScenarioForType,
  createExpectedOutputsForScenario,
  generateAccountsForType,
  generateTransactionsForType,
  generateProjectionsForType
};
